package com.cio.ibm.vanisdk.sample;

import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Handler;
import android.support.v7.app.ActionBarActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import com.ibm.cio.dto.QueryResult;
import com.ibm.cio.util.Logger;
import com.ibm.cio.vanisdk.IMCHelper;
import com.ibm.cio.vanisdk.VaniDelegate;
import com.ibm.cio.vanisdk.VaniManager;
import com.ibm.cio.vanisdk.VaniRecorderDelegate;

import java.net.URI;
import java.net.URISyntaxException;


public class MainActivity extends ActionBarActivity implements VaniDelegate, VaniRecorderDelegate {

    private static boolean isAuthorized = false; // false
    TextView transcriptionTxt;
    TextView serviceResultTxt;
    TextView statusTxt;
    Button recordBtn;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Log.i(TAG, "Am I authorized? ---> " + isAuthorized);

        statusTxt = (TextView) findViewById(R.id.statusTxt);
        serviceResultTxt = (TextView) findViewById(R.id.serviceResultTxt);
        transcriptionTxt = (TextView) findViewById(R.id.transcriptionTxt);
        recordBtn = (Button) findViewById(R.id.recordBtn);

        this.initVaniManager();

        SharedPreferences mSharedPreferences = getSharedPreferences("IMC_COOKIE", MODE_PRIVATE);
        String cookieData = mSharedPreferences.getString("COOKIE", "");
        String emailData = mSharedPreferences.getString("EMAIL", "");
        Long expireData = mSharedPreferences.getLong("EXPIRE", 0);
        if(System.currentTimeMillis() - expireData < 1800000 && cookieData.equals("") == false && emailData.equals("") == false){ // 30 minutes
            VaniManager.sharedInstance().setSessionCookie(cookieData);
            VaniManager.sharedInstance().setUserName(emailData);
            isAuthorized = true;
        }

        this.initSettings();
        this.onStatusChanged();

        if(isAuthorized){
            return;
        }

        this.startSignInActivity();
        this.onStatusChanged();
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }
    private static final int SHOW_SIGN_IN_ACTIVITY = 1;
    private static final int SHOW_TTS_ACTIVITY = 2;
    private static final int SHOW_SETTINGS_ACTIVITY = 3;
    private void startSignInActivity(){
        startActivityForResult(new Intent().setClass(MainActivity.this, SignInActivity.class), SHOW_SIGN_IN_ACTIVITY);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch(requestCode){
            case SHOW_SIGN_IN_ACTIVITY:
                if(resultCode == RESULT_OK){
                    isAuthorized = true;
                    this.updateStatus("Signed in successfully!");
                    this.onStatusChanged();
                    this.initSettings();
                }
                else if(resultCode == RESULT_FIRST_USER){
                    this.updateStatus("Failed to sign in.");
                }
                else{
                    // user cancelled
                }
                break;
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        switch (id){
            case R.id.action_settings:
                if(isAuthorized) {
                    startActivityForResult(new Intent().setClass(MainActivity.this, SettingsActivity.class), SHOW_SETTINGS_ACTIVITY);
                }
                else{
                    this.startSignInActivity();
                }
                break;
            case R.id.action_signin:
                this.startSignInActivity();
                return true;
            case R.id.action_tts:
                if(isAuthorized) {
                    startActivityForResult(new Intent().setClass(MainActivity.this, TTSActivity.class), SHOW_TTS_ACTIVITY);
                }
                else{
                    this.startSignInActivity();
                }
                break;
        }

        return super.onOptionsItemSelected(item);
    }

    private Handler getHandler(){
        if(handler == null){
            Log.e(TAG, "NULL HANDLER...........");
            this.handler = new Handler();
        }
        return this.handler;
    }


    // VANI SDK IMPLEMENTATION
    private static final String TAG = MainActivity.class.getSimpleName();
    // IMC Helper
    private IMCHelper lmc;
    // Default settings of WebSocket
    private boolean isUsingWebSocket = false;
    // Streaming mode
    private boolean isUsingStreaming = true;
    // VAD mode
    private boolean isUsingVAD = true;
    // Compression mode
    private boolean isUsingCompression = true;
    // Text to Speech
    private boolean isUsingTTS = false;
    // Use VANI Backend
    private boolean isUsingBackend = true;
    // Use VANI API
    private boolean isUsingVaniAPI = true;

    // Threads
    private Handler handler = null;
    //
    private enum STATE{
        STOPPED, RECORDING, STOPPING
    }
    // state
    private STATE currentState = STATE.STOPPED;

    private void setCurrentState(STATE state){
        this.currentState = state;
    }
    /**
     * Initializing instance of VANIManager and configuring the rest of parameters
     */
    private void initVaniManager(){
        VaniManager.sharedInstance().initWithContext(this.getVaniHost(), this.getApplicationContext(), this.isUsingVAD);
        VaniManager.sharedInstance().setAppVersion("v1.0");
        VaniManager.sharedInstance().setAppId("com.ibm.cio.vanisdk.sample");
        VaniManager.sharedInstance().setAppKey("9dd7cf4ff76f2fe8299459ae648a7dc8");

        VaniManager.sharedInstance().setDelegate(this);

        if (android.os.Build.VERSION.SDK_INT > android.os.Build.VERSION_CODES.GINGERBREAD) {
            android.os.StrictMode.ThreadPolicy policy = new android.os.StrictMode.ThreadPolicy.Builder()
                    .permitAll().build();
            android.os.StrictMode.setThreadPolicy(policy);
        }
    }

    private void initSettings(){
        VaniManager.sharedInstance().setUseStreaming(this.isUsingStreaming);
        VaniManager.sharedInstance().setUseVaniBackend(this.isUsingBackend);
        VaniManager.sharedInstance().setIsUsingVaniAPI(this.isUsingVaniAPI);

        VaniManager.sharedInstance().setUseTTS(this.isUsingTTS);
        VaniManager.sharedInstance().setTTSHost(VaniManager.IMC_SERVER_URL);
        VaniManager.sharedInstance().setSpeechModel(VaniManager.SPEECH_MODEL_en_US_CI4_16000);
        VaniManager.sharedInstance().setVaniService(VaniManager.VANI_SERVICE_FACES);
        VaniManager.sharedInstance().setUseVAD(this.isUsingVAD);

        VaniManager.sharedInstance().setUseWebSocket(this.isUsingWebSocket);
        VaniManager.sharedInstance().setUseCompression(this.isUsingCompression);

        // for WebSockets, set the duration for delaying connection closure in millisecond
        // for HTTP Connection, it will be timeout of reading response
        if(VaniManager.sharedInstance().isUsingWebSocket()) {
            VaniManager.sharedInstance().setUploaderTimeout(5000);
        }
        else{
            VaniManager.sharedInstance().setUploaderTimeout(0);
        }

        // set the timeout duration for waiting for the response
        VaniManager.sharedInstance().setRecordingTimeout(0);
        VaniManager.sharedInstance().setResponseTimeout(0);
    }

    /*
     *
     */
    public URI getVaniHost(){
        try {
            return new URI(VaniManager.IMC_SERVER_URL);
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void startRecording(View view){
        switch (this.currentState){
            case STOPPED:
                if(VaniManager.sharedInstance().getCurrentState() == VaniManager.STATE.STOPPED) {
                    this.startRecording();
                    this.setCurrentState(STATE.RECORDING);
                    this.onStatusChanged();
                }
                else{
                    VaniManager.sharedInstance().stopRecording();
                    this.setCurrentState(STATE.STOPPING);
                    this.onStatusChanged();
                }
                break;
            case RECORDING:
                VaniManager.sharedInstance().stopRecording();
                if(VaniManager.sharedInstance().isUseVAD()) {
                    this.setCurrentState(STATE.STOPPING);
                }
                else{
                    this.setCurrentState(STATE.STOPPED);
                }
                this.onStatusChanged();
                break;
            case STOPPING:
                VaniManager.sharedInstance().stopRecognizing();
                this.setCurrentState(STATE.STOPPED);
                this.onStatusChanged();
                break;
        }

    }

    private void startRecording() {
        // Start recording
        VaniManager.sharedInstance().startRecording();
        // Set recorder delegation
        VaniManager.sharedInstance().setRecorderDelegate(this);
        // Update status
        this.updateStatus("Please speak... Recording...");
    }

    /**
     * Delegate function, receive messages from VANI SDK
     */
    @Override
    public void receivedMessage(int code, QueryResult result) {
        switch(code){
            case VaniDelegate.OPEN:
                Logger.i(TAG, "################ receivedMessage.Open");
                this.updateStatus("Connection established.");
                break;
            case VaniDelegate.CLOSE:
                displayResult(result.getStatusCode(), result.getTranscript(), result.getListFaces());
                Logger.i(TAG, "################ receivedMessage.Close"); // Final results
                this.updateStatus("Finished, thanks for using VANI Service.");
//                if(VaniManager.sharedInstance().isUseVAD()){
                    this.currentState = STATE.STOPPED;
                    this.onStatusChanged();
//                }
                break;
            case VaniDelegate.ERROR:
                Logger.e(TAG, "################ receivedMessage.Error: "+result.getTranscript());
                if(VaniManager.sharedInstance().isUseVAD()){
                    this.currentState = STATE.STOPPED;
                    this.onStatusChanged();
                }
                this.onError(result);
                break;
            case VaniDelegate.MESSAGE:
                displayResult(result.getStatusCode(), result.getTranscript(), result.getListFaces()); // Instant results
                this.updateStatus("Transcript is available.");
                if(VaniManager.sharedInstance().isUseVAD()){
                    this.currentState = STATE.STOPPED;
                    this.onStatusChanged();
                }
                break;
            case VaniDelegate.WAIT:
                this.updateStatus("Thinking...");
                this.currentState = STATE.STOPPING;
                this.onStatusChanged();
                break;
        }
    }

    /**
     * Error message handler
     *
     * @param result
     */
    private void onError(QueryResult result){
        this.currentState = STATE.STOPPED;
        this.onStatusChanged();
        switch(result.getStatusCode()){
            case QueryResult.TIME_OUT:
                this.updateStatus("Timeout...");
                break;
            case QueryResult.CANCEL_ALL:
                this.updateStatus("Query has been cancelled...");
                break;
            case QueryResult.CONNECTION_FAILED:
                this.updateStatus("Connection failure...");
                break;
            case QueryResult.STOP_SOON:
                this.updateStatus("Clicks on record button are too frequent...");
                break;
            case QueryResult.CONNECTION_CLOSED:
                this.updateStatus("Connection has been closed accidentally...");
                break;
            case QueryResult.BAD_REQUEST:
                this.updateStatus("Voice recognition failed");
                break;
            case QueryResult.AUTHENTICATION_FAILED:
                this.updateStatus("Authentication failed");
                this.startSignInActivity();
                break;
            case QueryResult.EMPTY_TRANSCRIPTION_ERROR:
                this.updateStatus("Empty transcription...");
                break;
            case QueryResult.UNKNOWN_ERROR:
                this.updateStatus("Failed to get the transcript...");
                break;
            default:
                this.updateStatus(result.getTranscript());
        }
    }

    @Override
    public void onRecordingCompleted(byte[] rawAudioData) {
        // TODO Auto-generated method stub
        Logger.e(TAG, "###"+rawAudioData.length+"###");
    }

    /**
     * Update status
     *
     * @param status
     */
    public void updateStatus(final String status){
        final Runnable runnableUi = new Runnable(){
            @Override
            public void run() {
                statusTxt.setText(status);
            }
        };

        this.getHandler().post(runnableUi);
    }
    /**
     * Display the faces results
     *
     * @param result
     */
    public void displayResult(int code, final String result, final String serviceResult){
        final Runnable runnableUi = new Runnable(){
            @Override
            public void run() {
                if(result.equals("")){
                    return;
                }
                VaniManager.sharedInstance().transcript = result;
                transcriptionTxt.setText(result);

                serviceResultTxt.setText(serviceResult);
            }
        };

        this.getHandler().post(runnableUi);
    }

    /**
     * Update native UI
     */
    private void onStatusChanged(){
        Logger.e(TAG, "onStatusChanged+"+currentState);
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                recordBtn.setEnabled(isAuthorized);

                if(currentState == STATE.STOPPED){
                    recordBtn.setText("Speak");
                }
                else if(currentState == STATE.RECORDING){
                    recordBtn.setText("Stop");
                }
                else if(currentState == STATE.STOPPING){
                    recordBtn.setText("Cancel");
                }
                else{
                    //
                }
            }
        };

        this.getHandler().post(runnable);
    }
}
